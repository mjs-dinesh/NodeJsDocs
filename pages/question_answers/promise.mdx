### Promise

```js
const promise = (isResolve) => {
  return new Promise((resolve, reject) => {
    if (isResolve) {
      setTimeout(() => {
        resolve("Success");
      }, 2000);
    } else {
      setTimeout(() => {
        reject("Error");
      }, 2000);
    }
  });
};

const promiseResult = async () => {
  await promise(true)
    .then((res) => console.log({ res }))
    .catch((err) => console.log(err));
  await promise(false)
    .then((res) => console.log({ res }))
    .catch((err) => console.log({ err }));
};

promiseResult();
```

##### 2.Can you explain what Promises are in JavaScript and provide an example of making nested Promises?

Promises in JavaScript are a way to handle asynchronous operations. They are objects that represent a value that may not be available yet but will be resolved in the future, either successfully or unsuccessfully. Promises have three states: pending, fulfilled, and rejected.

Here is an example of making nested Promises:

```js
let promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Promise 1 resolved");
  }, 1000);
});

let promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Promise 2 resolved");
  }, 2000);
});

let promise3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Promise 3 resolved");
  }, 3000);
});

promise1
  .then((result1) => {
    console.log(result1);
    return promise2;
  })
  .then((result2) => {
    console.log(result2);
    return promise3;
  })
  .then((result3) => {
    console.log(result3);
  })
  .catch((error) => {
    console.error(error);
  });
```

In this example, we create three Promises `promise1`, `promise2`, and `promise3` that resolve after 1, 2, and 3 seconds respectively. We then chain the Promises using the `then()` method. The first `then()` block logs the result of `promise1` and returns `promise2`. The second `then()` block logs the result of `promise2` and returns `promise3`. The third `then()` block logs the result of `promise3`. The `catch()` block handles any errors that occur during the Promise chain.

This example demonstrates how Promises can be used to handle asynchronous operations in a sequential manner.

##### 3.How can you avoid using nested Promises in JavaScript?

To avoid using nested Promises in JavaScript, we can use Promise chaining. Promise chaining allows us to write more readable and maintainable code by avoiding the nesting of Promises.

Here is an example:

```js
function getUser(id) {
  return new Promise((resolve, reject) => {
    // Fetch user data from database using the provided id
    let user = { id: id, name: "John Doe" };
    resolve(user);
  });
}

function getUserPosts(user) {
  return new Promise((resolve, reject) => {
    // Fetch user's posts from database using the user object
    let posts = [
      { id: 1, title: "Post 1" },
      { id: 2, title: "Post 2" },
    ];
    resolve(posts);
  });
}

function getPostComments(post) {
  return new Promise((resolve, reject) => {
    // Fetch comments for the post using the post object
    let comments = [
      { id: 1, text: "Comment 1" },
      { id: 2, text: "Comment 2" },
    ];
    resolve(comments);
  });
}

// Promise chaining example
getUser(1)
  .then((user) => getUserPosts(user))
  .then((posts) => getPostComments(posts[0]))
  .then((comments) => console.log(comments))
  .catch((error) => console.log(error));
```

In this example, we chain the Promises returned by each function using the `.then()` method, rather than nesting them. This makes the code more readable and easier to maintain.
