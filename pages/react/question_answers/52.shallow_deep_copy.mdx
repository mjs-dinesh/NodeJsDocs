### What are shallow and deep copy in JavaScript, and how can you use various techniques
such as object spread, object.assign(), JSON.parse(), and JSON.stringify() to create copies
of arrays and objects with different levels of depth and immutability?

In JavaScript, the concepts of shallow copy and deep copy are related to creating copies of arrays and objects, and they differ in terms of how they handle nested structures and references.

### Shallow Copy:

A shallow copy creates a new object or array, but it only copies the top-level structure. If the original object or array contains nested objects or arrays, those nested structures are still referenced, meaning changes to the nested structures will be reflected in both the original and copied objects.

#### Techniques for Shallow Copy:

1. **Object Spread (for objects):**

   ```javascript
   const originalObject = { a: 1, b: { c: 2 } };
   const shallowCopyObject = { ...originalObject };
   ```

2. **Object.assign() (for objects):**

   ```javascript
   const originalObject = { a: 1, b: { c: 2 } };
   const shallowCopyObject = Object.assign({}, originalObject);
   ```

3. **Array Spread (for arrays):**

   ```javascript
   const originalArray = [1, [2, 3]];
   const shallowCopyArray = [...originalArray];
   ```

### Deep Copy:

A deep copy creates a new object or array along with new copies of all nested objects and arrays. This means that changes to the nested structures will not affect the original object or array, and vice versa.

#### Techniques for Deep Copy:

1. **JSON.parse() and JSON.stringify() (for both objects and arrays):**

   ```javascript
   const originalObject = { a: 1, b: { c: 2 } };
   const deepCopyObject = JSON.parse(JSON.stringify(originalObject));

   const originalArray = [1, [2, 3]];
   const deepCopyArray = JSON.parse(JSON.stringify(originalArray));
   ```

   **Note:** This method has limitations, and it won't work well with objects containing functions, undefined, or circular references.

### Immutability:

Using these techniques for copying objects and arrays helps in achieving a form of immutability. Immutability is the practice of not modifying the original data structures but creating new ones instead. This is particularly useful in scenarios where maintaining the state of data over time or in a reactive programming context is important.

However, it's important to note that these methods only address the structure of objects and arrays, not the content of non-primitive values (e.g., objects, arrays) within them. If the content of nested structures is also mutable, modifications to them may still affect both the original and copied data.

Choose the appropriate method based on your specific use case, considering factors such as performance, ease of use, and compatibility with your data structures. Keep in mind that deep copying complex structures may have performance implications, especially for large datasets.