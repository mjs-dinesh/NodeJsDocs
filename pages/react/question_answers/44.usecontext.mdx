### What are the useState, useEffect, and useContext hooks in React, and how are they used

to manage state, perform side effects, and handle global data respectively?

In React, the `useState`, `useEffect`, and `useContext` are three essential hooks that provide functional components with state management, side effect handling, and context integration. Here's an overview of each:

### 1. `useState` Hook:

The `useState` hook allows functional components to manage state in a way similar to class components. It returns an array with two elements: the current state value and a function to update the state.

#### Example:

```jsx
import React, { useState } from "react";

const Counter = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

In this example, `count` is the state variable, and `setCount` is the function to update its value. The initial state is set to `0`.

### 2. `useEffect` Hook:

The `useEffect` hook is used to perform side effects in functional components. It replaces lifecycle methods like `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`. It runs after every render and can handle tasks like data fetching, subscriptions, or manual DOM manipulations.

#### Example:

```jsx
import React, { useState, useEffect } from "react";

const DataFetcher = () => {
  const [data, setData] = useState(null);

  useEffect(() => {
    // Effect will run after each render
    const fetchData = async () => {
      const response = await fetch("https://api.example.com/data");
      const result = await response.json();
      setData(result);
    };

    fetchData();

    // Cleanup function (optional) - runs before the next effect
    return () => {
      console.log("Cleanup");
    };
  }, []); // Empty dependency array means the effect runs only once (on mount)

  return (
    <div>
      <p>Data: {data ? JSON.stringify(data) : "Loading..."}</p>
    </div>
  );
};
```

In this example, the `useEffect` hook fetches data from an API after the initial render. The cleanup function, defined in `return`, runs before the next effect or on component unmount.

### 3. `useContext` Hook:

The `useContext` hook is used to access values from the React context. It allows functional components to subscribe to a context and read its current value.

#### Example:

```jsx
import React, { useContext } from "react";

// Create a context
const ThemeContext = React.createContext("light");

const ThemedComponent = () => {
  // Use the useContext hook to access the current context value
  const theme = useContext(ThemeContext);

  return (
    <div>
      <p>Current Theme: {theme}</p>
    </div>
  );
};

// Wrap a part of the component tree with the context provider
const App = () => (
  <ThemeContext.Provider value="dark">
    <ThemedComponent />
  </ThemeContext.Provider>
);
```

In this example, the `ThemedComponent` uses the `useContext` hook to access the current theme value from the `ThemeContext` provider.

These hooks play a crucial role in functional component development in React:

- **`useState`:** Manages state within functional components.
- **`useEffect`:** Handles side effects, such as data fetching or subscriptions, after component renders.

- **`useContext`:** Allows functional components to consume values from React context.

By using these hooks, you can achieve powerful state management, side effect handling, and global data sharing within functional components in a more concise and expressive manner compared to class components.
