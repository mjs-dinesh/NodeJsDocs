### Explain React Hooks.

React Hooks are functions that allow functional components to use state and lifecycle features that were previously only available in class components. Hooks were introduced in React version 16.8 to address the challenges of reusing stateful logic and managing side effects in functional components.

There are several built-in hooks provided by React, and developers can also create custom hooks to encapsulate reusable logic.

### Built-in Hooks:

#### 1. `useState`:

```jsx
import React, { useState } from "react";

const MyComponent = () => {
  // Declare a state variable 'count' with an initial value of 0
  const [count, setCount] = useState(0);

  // Use 'count' and 'setCount' in the component
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

#### 2. `useEffect`:

```jsx
import React, { useState, useEffect } from "react";

const MyComponent = () => {
  const [data, setData] = useState(null);

  // useEffect is used for side effects (e.g., data fetching, subscriptions)
  useEffect(() => {
    // Code to run after the component renders

    // Clean-up function (optional)
    return () => {
      // Code to run before the component is unmounted or before the next render
    };
  }, []); // Dependency array (optional)

  return <div>{data}</div>;
};
```

#### 3. `useContext`:

```jsx
import React, { useContext } from "react";
import MyContext from "./MyContext";

const MyComponent = () => {
  // Access context value using useContext hook
  const contextValue = useContext(MyContext);

  return <div>{contextValue}</div>;
};
```

#### 4. `useReducer`:

```jsx
import React, { useReducer } from "react";

const initialState = { count: 0 };

const reducer = (state, action) => {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    default:
      return state;
  }
};

const MyComponent = () => {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>Increment</button>
    </div>
  );
};
```

### Custom Hooks:

Developers can create custom hooks to encapsulate reusable logic and share it across components.

```jsx
import { useState, useEffect } from "react";

const useFetchData = (url) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
      } catch (error) {
        console.error("Error fetching data:", error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading };
};

// Usage
const MyComponent = () => {
  const { data, loading } = useFetchData("https://api.example.com/data");

  return <div>{loading ? <p>Loading...</p> : <p>Data: {data}</p>}</div>;
};
```

### Key Concepts:

1. **Rules of Hooks:**

   - Hooks should be called at the top level of a functional component or a custom hook. They should not be called inside loops, conditions, or nested functions.

2. **Dependency Array:**

   - The dependency array in the `useEffect` and other hooks specifies the values from the component's scope that the effect depends on. When the values in the dependency array change, the effect is re-run.

3. **Custom Hooks:**
   - Custom hooks are functions that start with the word "use" and can use other hooks inside them. They provide a way to reuse and share stateful logic across components.

React Hooks have significantly improved the development experience in React by making functional components more powerful and expressive. They offer a more concise and readable way to manage state and side effects compared to class components.
